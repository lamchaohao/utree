//
//  IIViewDeckController.m
//  IIViewDeck
//
//  Copyright (C) 2011-2015, ViewDeck
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy of
//  this software and associated documentation files (the "Software"), to deal in
//  the Software without restriction, including without limitation the rights to
//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//  of the Software, and to permit persons to whom the Software is furnished to do
//  so, subject to the following conditions:
// 
//  The above copyright notice and this permission notice shall be included in all
//  copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
//

#define II_FLOAT_EQUAL(x, y) (((x) - (y)) == 0.0f)
#define II_STRING_EQUAL(a, b) ((a == nil && b == nil) || (a != nil && [a isEqualToString:b]))

#define II_CGRectOffsetRightAndShrink(rect, offset)         \
({                                                        \
__typeof__(rect) __r = (rect);                          \
__typeof__(offset) __o = (offset);                      \
(CGRect) {  { __r.origin.x, __r.origin.y },            \
{ __r.size.width - __o, __r.size.height }  \
};                                            \
})
#define II_CGRectOffsetTopAndShrink(rect, offset)           \
({                                                        \
__typeof__(rect) __r = (rect);                          \
__typeof__(offset) __o = (offset);                      \
(CGRect) { { __r.origin.x,   __r.origin.y    + __o },   \
{ __r.size.width, __r.size.height - __o }    \
};                                             \
})
#define II_CGRectOffsetBottomAndShrink(rect, offset)        \
({                                                        \
__typeof__(rect) __r = (rect);                          \
__typeof__(offset) __o = (offset);                      \
(CGRect) { { __r.origin.x, __r.origin.y },              \
{ __r.size.width, __r.size.height - __o}     \
};                                             \
})
#define II_CGRectShrink(rect, w, h)                             \
({                                                            \
__typeof__(rect) __r = (rect);                              \
__typeof__(w) __w = (w);                                    \
__typeof__(h) __h = (h);                                    \
(CGRect) {  __r.origin,                                     \
{ __r.size.width - __w, __r.size.height - __h}   \
};                                                 \
})

#import "IIViewDeckController.h"
#import <objc/runtime.h>
#import <QuartzCore/QuartzCore.h>
#import <objc/message.h>
#import "IIWrapController.h"


static const IIViewDeckSide IIViewDeckNoSide = 0;


inline NSString* NSStringFromIIViewDeckSide(IIViewDeckSide side) {
    switch (side) {
        case IIViewDeckLeftSide:
            return @"left";
            
        case IIViewDeckRightSide:
            return @"right";

        case IIViewDeckNoSide:
            return @"no";

        default:
            return @"unknown";
    }
}


static const UIViewAnimationOptions DefaultSwipedAnimationCurve = UIViewAnimationOptionCurveEaseOut;

static NSTimeInterval durationToAnimate(CGFloat pointsToAnimate, CGFloat velocity)
{
    NSTimeInterval animationDuration = pointsToAnimate / ABS(velocity);
    // adjust duration for easing curve, if necessary
    if (DefaultSwipedAnimationCurve != UIViewAnimationOptionCurveLinear) animationDuration *= 1.25;
    return animationDuration;
}

#define DEFAULT_DURATION 0.0


@interface IIViewDeckView : UIView {
    BOOL _userInteractionEnabled;
    BOOL _needsOffsetAdjustment;
}

@property (nonatomic, assign) BOOL allowUserInteractionEnabled;

- (void)setNeedsOffsetAdjustment;
- (BOOL)needsOffsetAdjustment;

@end


@interface UIViewController (UIViewDeckController_ViewContainmentEmulation_Fakes)
- (void)vdc_addChildViewController:(UIViewController *)childController;
- (void)vdc_removeFromParentViewController;
- (void)vdc_willMoveToParentViewController:(UIViewController *)parent;
- (void)vdc_didMoveToParentViewController:(UIViewController *)parent;
@end


@interface IIViewDeckController () <UIGestureRecognizerDelegate> {
    CGPoint _panOrigin;
    UInt32 _viewAppeared;
    BOOL _viewFirstAppeared;
    UInt32 _sideAppeared[6];
    CGFloat _ledge[5];
    CGFloat _offset, _maxLedge;
    CGSize _preRotationSize, _preRotationCenterSize;
    BOOL _preRotationIsLandscape;
    UIInterfaceOrientation _willAppearShouldArrangeViewsAfterRotation;
    CGPoint _willAppearOffset;
    NSMutableArray* _finishTransitionBlocks;
    int _disabledUserInteractions;
    BOOL _needsAddPannersIfAllPannersAreInactive;
    NSMutableSet* _disabledPanClasses;
}

@property (nonatomic, retain) UIView* referenceView;
@property (nonatomic, readonly) CGRect referenceBounds;
@property (nonatomic, readonly) CGRect centerViewBounds;
@property (nonatomic, readonly) CGRect sideViewBounds;
@property (nonatomic, retain) NSMutableArray* panners;
@property (nonatomic, assign) CGFloat originalShadowRadius;
@property (nonatomic, assign) CGFloat originalShadowOpacity;
@property (nonatomic, retain) UIColor* originalShadowColor;
@property (nonatomic, assign) CGSize originalShadowOffset;
@property (nonatomic, retain) UIBezierPath* originalShadowPath;
@property (nonatomic, retain) UIButton* centerTapper;
@property (nonatomic, weak, readwrite) UIView* centerView;
@property (nonatomic, readonly) UIView* slidingControllerView;
@property (nonatomic, assign) BOOL isObservingView;
@property (nonatomic, assign) BOOL isObservingSelf;

@end


@interface UIViewController (UIViewDeckItem_Internal)

// internal setter for the viewDeckController property on UIViewController
- (void)setViewDeckController:(IIViewDeckController*)viewDeckController;

@end

@interface UIViewController (UIViewDeckController_ViewContainmentEmulation) 

- (void)addChildViewController:(UIViewController *)childController;
- (void)removeFromParentViewController;
- (void)willMoveToParentViewController:(UIViewController *)parent;
- (void)didMoveToParentViewController:(UIViewController *)parent;

@end


@implementation IIViewDeckController

#pragma mark - Initalisation and deallocation

static void commonInitWithCenterViewController(IIViewDeckController *self, UIViewController *centerController)
{
    self.elastic = YES;
    self->_willAppearShouldArrangeViewsAfterRotation = (UIInterfaceOrientation)UIDeviceOrientationUnknown;
    self.panningMode = IIViewDeckFullViewPanning;
    self.panningCancelsTouchesInView = YES; // let's default to standard IOS behavior.
    self.navigationControllerBehavior = IIViewDeckNavigationControllerContained;
    self.centerhiddenInteractivity = IIViewDeckCenterHiddenUserInteractive;
    self.sizeMode = IIViewDeckLedgeSizeMode;
    self->_viewAppeared = 0;
    self->_viewFirstAppeared = NO;
    self.resizesCenterView = NO;
    self.automaticallyUpdateTabBarItems = NO;
    self.centerViewOpacity = 1;
    self.centerViewCornerRadius = 0;
    self.panners = [NSMutableArray array];
    self.enabled = YES;
    self->_offset = 0;
    self.bounceDurationFactor = 0.3;
    self.openSlideAnimationDuration = 0.3;
    self.closeSlideAnimationDuration = 0.3;
    
    self->_disabledPanClasses = [NSMutableSet setWithObject:[UISlider class]];
#ifndef EXTRA_APPSTORE_SAFETY
    [self disablePanOverViewsOfClass:NSClassFromString(@"UITableViewCellReorderControl")];
#endif   

    self.delegate = nil;
    self.delegateMode = IIViewDeckDelegateOnly;
    
    self.originalShadowRadius = 0;
    self.originalShadowOffset = CGSizeZero;
    self.originalShadowColor = nil;
    self.originalShadowOpacity = 0;
    self.originalShadowPath = nil;
    
    self.centerController = centerController;
    self.leftController = nil;
    self.rightController = nil;
    
    self.shadowEnabled = YES;

    self->_ledge[IIViewDeckLeftSide] = self->_ledge[IIViewDeckRightSide] = 44;
}

- (id)initWithCoder:(NSCoder *)aDecoder
{
    if ((self = [super initWithCoder:aDecoder])) {
        commonInitWithCenterViewController(self, nil);
    }
    return self;
}

- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
{
    if ((self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil])) {
        commonInitWithCenterViewController(self, nil);
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController {
    if ((self = [super initWithNibName:nil bundle:nil])) {
        commonInitWithCenterViewController(self, centerController);
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController leftViewController:(UIViewController*)leftController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.leftController = leftController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController rightViewController:(UIViewController*)rightController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.rightController = rightController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController leftViewController:(UIViewController*)leftController rightViewController:(UIViewController*)rightController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.leftController = leftController;
        self.rightController = rightController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController topViewController:(UIViewController*)topController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.topController = topController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController bottomViewController:(UIViewController*)bottomController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.bottomController = bottomController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController topViewController:(UIViewController*)topController bottomViewController:(UIViewController*)bottomController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.topController = topController;
        self.bottomController = bottomController;
    }
    return self;
}

- (id)initWithCenterViewController:(UIViewController*)centerController leftViewController:(UIViewController*)leftController rightViewController:(UIViewController*)rightController topViewController:(UIViewController*)topController bottomViewController:(UIViewController*)bottomController {
    if ((self = [self initWithCenterViewController:centerController])) {
        self.leftController = leftController;
        self.rightController = rightController;
        self.topController = topController;
        self.bottomController = bottomController;
    }
    return self;
}

- (void)cleanup {
    self.originalShadowRadius = 0;
    self.originalShadowOpacity = 0;
    self.originalShadowColor = nil;
    self.originalShadowOffset = CGSizeZero;
    self.originalShadowPath = nil;

    _slidingController = nil;
    self.referenceView = nil;
    self.centerView = nil;
    self.centerTapper = nil;
}

- (void)dealloc {
    [self cleanup];
    
    self.centerController.viewDeckController = nil;
    self.centerController = nil;
    self.leftController.viewDeckController = nil;
    self.leftController = nil;
    self.rightController.viewDeckController = nil;
    self.rightController = nil;
    
    [self removePanners];
    self.panners = nil;
    
    // observations related to UIViewController properties
    if (self.isObservingSelf) {
        @try {
            [self removeObserver:self forKeyPath:@"parentViewController"];
            [self removeObserver:self forKeyPath:@"presentingViewController"];
            self.isObservingSelf = NO;
        } @catch(id anException) {
            
        }
    }
    if (self.isObservingView) {
        @try {
            [self.view removeObserver:self forKeyPath:@"bounds"];
            self.isObservingView = NO;
        } @catch(id anException) {
            
        }
    }
}



#pragma mark - View Lifecycle

- (void)viewDidLoad {
    [super viewDidLoad];
    
    UIView *centerView = [[UIView alloc] initWithFrame:self.view.bounds];
    centerView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    centerView.clipsToBounds = YES;
    [self.view addSubview:centerView];
    self.centerView = centerView;
    
    [self exchangeViewFromController:nil toController:self.centerController inContainerView:centerView];
    
    self.originalShadowRadius = 0;
    self.originalShadowOpacity = 0;
    self.originalShadowColor = nil;
    self.originalShadowOffset = CGSizeZero;
    self.originalShadowPath = nil;
}

- (void)exchangeViewFromController:(UIViewController *)oldController toController:(UIViewController *)newController inContainerView:(UIView *)containerView {
    if (oldController == nil && newController == nil) {
        return;
    }
    
    BOOL viewVisible = (self.view.window != nil);
    if (viewVisible) {
        [oldController beginAppearanceTransition:NO animated:NO];
        [newController beginAppearanceTransition:YES animated:NO];
    }
    
    newController.view.frame = containerView.bounds;
    newController.view.autoresizingMask = (UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight);
    
    [containerView addSubview:newController.view];
    [oldController.view removeFromSuperview];
    
    if (viewVisible) {
        [newController endAppearanceTransition];
        [oldController endAppearanceTransition];
    }
}



#pragma mark - Child Controller Lifecycle

- (void)exchangeViewController:(UIViewController *)oldController withViewController:(UIViewController *)newController viewTransition:(void(^)(void))viewTransition {
    [oldController willMoveToParentViewController:nil];
    [self addChildViewController:newController];
    
    if (self.isViewLoaded && viewTransition) {
        viewTransition();
    }
    
    [newController didMoveToParentViewController:self];
    [oldController removeFromParentViewController];
}

- (void)setCenterController:(UIViewController *)centerController {
    if (_centerController == centerController) {
        return;
    }
    
    UIViewController *oldController = _centerController;
    _centerController = centerController;
    
    [self exchangeViewController:oldController withViewController:centerController viewTransition:^{
        [self exchangeViewFromController:oldController toController:centerController inContainerView:self.centerView];
    }];
    
    [self setNeedsStatusBarAppearanceUpdate];
    
    // TODO: Start monitoring tab bar items here...
}

- (void)setLeftController:(UIViewController *)leftController {
    if (_leftController == leftController) {
        return;
    }
    
    UIViewController *oldController = _leftController;
    _leftController = leftController;
    
    [self exchangeViewController:oldController withViewController:leftController viewTransition:^{
        // TODO: Check if left view controller is currently visible and exchange views
    }];
}

- (void)setRightController:(UIViewController *)rightController {
    if (_rightController == rightController) {
        return;
    }
    
    UIViewController *oldController = _rightController;
    _rightController = rightController;
    
    [self exchangeViewController:oldController withViewController:rightController viewTransition:^{
        // TODO: Check if right view controller is currently visible and exchange views
    }];
}



#pragma mark left size

- (void)setLeftSize:(CGFloat)leftSize {
    [self setLeftSize:leftSize completion:nil];
}

- (void)setLeftSize:(CGFloat)leftSize completion:(void(^)(BOOL finished))completion {
//    [self setSize:leftSize forSide:IIViewDeckLeftSide completion:completion];
}

- (CGFloat)leftSize {
    return 0.0;//[self sizeForSide:IIViewDeckLeftSide];
}

- (CGFloat)leftViewSize {
    return [self ledgeAsSize:_ledge[IIViewDeckLeftSide] mode:IIViewDeckViewSizeMode forSide:IIViewDeckLeftSide];
}

- (CGFloat)leftLedgeSize {
    return [self ledgeAsSize:_ledge[IIViewDeckLeftSide] mode:IIViewDeckLedgeSizeMode forSide:IIViewDeckLeftSide];
}

#pragma mark right size

- (void)setRightSize:(CGFloat)rightSize {
    [self setRightSize:rightSize completion:nil];
}

- (void)setRightSize:(CGFloat)rightSize completion:(void(^)(BOOL finished))completion {
//    [self setSize:rightSize forSide:IIViewDeckRightSide completion:completion];
}
    
- (CGFloat)rightSize {
    return 0.0;//[self sizeForSide:IIViewDeckRightSide];
}

- (CGFloat)rightViewSize {
    return [self ledgeAsSize:_ledge[IIViewDeckRightSide] mode:IIViewDeckViewSizeMode forSide:IIViewDeckRightSide];
}

- (CGFloat)rightLedgeSize {
    return [self ledgeAsSize:_ledge[IIViewDeckRightSide] mode:IIViewDeckLedgeSizeMode forSide:IIViewDeckRightSide];
}


#pragma mark max size

- (void)setMaxSize:(CGFloat)maxSize {
    [self setMaxSize:maxSize completion:nil];
}

- (void)setMaxSize:(CGFloat)maxSize completion:(void(^)(BOOL finished))completion {
    if (/*[self sideControllerCount]*/0 > 1) {
        NSLog(@"IIViewDeckController: warning: setting maxLedge with more than one side controllers. Value will be ignored.");
        return;
    }
    
    [self doForControllers:^(UIViewController* controller, IIViewDeckSide side) {
        if (controller) {
            _maxLedge = [self sizeAsLedge:maxSize forSide:side];
            if (_ledge[side] > _maxLedge) {
//                [self setSize:maxSize forSide:side completion:completion];
            } else if (completion) {
                completion(NO);
            }
//            [self setSlidingFrameForOffset:_offset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES]; // should be animated
        }
    }];
}

- (CGFloat)maxSize {
    return _maxLedge;
}

- (CGFloat)sizeAsLedge:(CGFloat)size forSide:(IIViewDeckSide)side {
    if (_sizeMode == IIViewDeckLedgeSizeMode)
        return size;
    else {
        return ((side == IIViewDeckLeftSide || side == IIViewDeckRightSide)
                ? self.referenceBounds.size.width : self.referenceBounds.size.height) - size;
    }
}

- (CGFloat)ledgeAsSize:(CGFloat)ledge forSide:(IIViewDeckSide)side {
    return [self ledgeAsSize:ledge mode:_sizeMode forSide:side];
}

- (CGFloat)ledgeAsSize:(CGFloat)ledge mode:(IIViewDeckSizeMode)mode forSide:(IIViewDeckSide)side {
    if (mode == IIViewDeckLedgeSizeMode)
        return ledge;
    else
        return ((side == IIViewDeckLeftSide || side == IIViewDeckRightSide)
                ? self.referenceBounds.size.width : self.referenceBounds.size.height) - ledge;
}



#pragma mark - Status Bar

- (UIViewController *)childViewControllerForStatusBarHidden {
    return self.centerController;
}

- (UIViewController *)childViewControllerForStatusBarStyle {
    return self.centerController;
}



#pragma mark - Rotation

- (BOOL)shouldAutorotate {
    if (self.centerController) {
        return self.centerController.shouldAutorotate;
    }
    
    return [super shouldAutorotate];
}

- (UIInterfaceOrientationMask)supportedInterfaceOrientations {
    if (self.centerController) {
        return self.centerController.supportedInterfaceOrientations;
    }
    
    return [super supportedInterfaceOrientations];
}

- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {
    if (self.centerController) {
        return self.centerController.preferredInterfaceOrientationForPresentation;
    }
    
    return [super preferredInterfaceOrientationForPresentation];
}

- (void)setLedgeValue:(CGFloat)ledge forSide:(IIViewDeckSide)side {
    if (_maxLedge > 0)
        ledge = MIN(_maxLedge, ledge);

    _ledge[side] = [self performDelegate:@selector(viewDeckController:changesLedge:forSide:) ledge:ledge side:side];
}

#pragma mark - Notify

- (CGFloat)ledgeOffsetForSide:(IIViewDeckSide)viewDeckSide {
    switch (viewDeckSide) {
        case IIViewDeckLeftSide:
            return self.referenceBounds.size.width - _ledge[viewDeckSide];
            break;
            
        case IIViewDeckRightSide:
            return _ledge[viewDeckSide] - self.referenceBounds.size.width;
            break;
    }
    
    return 0;
}

- (void)doForControllers:(void(^)(UIViewController* controller, IIViewDeckSide side))action {
    if (!action) return;
    for (IIViewDeckSide side=IIViewDeckLeftSide; side<=IIViewDeckRightSide; side++) {
        action(_controllers[side], side);
    }
}

- (UIViewController*)controllerForSide:(IIViewDeckSide)viewDeckSide {
    return viewDeckSide == IIViewDeckNoSide ? nil : _controllers[viewDeckSide];
}

- (IIViewDeckSide)oppositeOfSide:(IIViewDeckSide)viewDeckSide {
    switch (viewDeckSide) {
        case IIViewDeckLeftSide:
            return IIViewDeckRightSide;
            
        case IIViewDeckRightSide:
            return IIViewDeckLeftSide;
            
        default:
            return IIViewDeckNoSide;
    }
}

- (IIViewDeckSide)sideForController:(UIViewController*)controller {
    for (IIViewDeckSide side=IIViewDeckLeftSide; side<=IIViewDeckRightSide; side++) {
        if (_controllers[side] == controller) return side;
    }
    
    return NSNotFound;
}




- (BOOL)checkCanOpenSide:(IIViewDeckSide)viewDeckSide {
    return ![self isSideOpen:viewDeckSide] && [self checkDelegate:@selector(viewDeckController:shouldOpenViewSide:) side:viewDeckSide];
}

- (BOOL)checkCanCloseSide:(IIViewDeckSide)viewDeckSide {
    return ![self isSideClosed:viewDeckSide] && [self checkDelegate:@selector(viewDeckController:shouldCloseViewSide:animated:) side:viewDeckSide];
}

- (void)notifyWillOpenSide:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated {
    if (viewDeckSide == IIViewDeckNoSide) return;
    [self notifyAppearanceForSide:viewDeckSide animated:animated from:0 to:1];

    if ([self isSideClosed:viewDeckSide]) {
        [self performDelegate:@selector(viewDeckController:willOpenViewSide:animated:) side:viewDeckSide animated:animated];
    }
}

- (void)notifyDidOpenSide:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated {
    if (viewDeckSide == IIViewDeckNoSide) return;
    [self notifyAppearanceForSide:viewDeckSide animated:animated from:1 to:2];

    if ([self isSideOpen:viewDeckSide]) {
        [self performDelegate:@selector(viewDeckController:didOpenViewSide:animated:) side:viewDeckSide animated:animated];
    }
}

- (void)notifyWillCloseSide:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated {
    if (viewDeckSide == IIViewDeckNoSide) return;
    [self notifyAppearanceForSide:viewDeckSide animated:animated from:2 to:1];

    if (![self isSideClosed:viewDeckSide]) {
        [self performDelegate:@selector(viewDeckController:willCloseViewSide:animated:) side:viewDeckSide animated:animated];
    }
}

- (void)notifyDidCloseSide:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated {
    if (viewDeckSide == IIViewDeckNoSide) return;

    [self notifyAppearanceForSide:viewDeckSide animated:animated from:1 to:0];
    if ([self isSideClosed:viewDeckSide]) {
        [self performDelegate:@selector(viewDeckController:didCloseViewSide:animated:) side:viewDeckSide animated:animated];
        [self performDelegate:@selector(viewDeckController:didShowCenterViewFromSide:animated:) side:viewDeckSide animated:animated];
    }
}

- (void)notifyDidChangeOffset:(CGFloat)offset panning:(BOOL)panning {
    [self performDelegate:@selector(viewDeckController:didChangeOffset:panning:) offset:offset panning:panning];
}

- (void)notifyAppearanceForSide:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated from:(uint)from to:(uint)to {
    if (viewDeckSide == IIViewDeckNoSide)
        return;
    
    if (_viewAppeared < to) {
        _sideAppeared[viewDeckSide] = to;
        return;
    }

    SEL selector = nil;
    if (from < to) {
        if (_sideAppeared[viewDeckSide] > from)
            return;
        
        if (to == 1)
            selector = @selector(_forwardViewWillAppear:onViewController:);
        else if (to == 2)
            selector = @selector(_forwardViewDidAppear:onViewController:);
    }
    else {
        if (_sideAppeared[viewDeckSide] < from)
            return;
        
        if (to == 1)
            selector = @selector(_forwardViewWillDisappear:onViewController:);
        else if (to == 0)
            selector = @selector(_forwardViewDidDisappear:onViewController:);
    }
    
    _sideAppeared[viewDeckSide] = to;
}

- (void)transitionAppearanceFrom:(uint)from to:(uint)to animated:(BOOL)animated {
    SEL selector = nil;
    if (from < to) {
        if (to == 1)
            selector = @selector(_forwardViewWillAppear:onViewController:);
        else if (to == 2)
            selector = @selector(_forwardViewDidAppear:onViewController:);
    }
    else {
        if (to == 1)
            selector = @selector(_forwardViewWillDisappear:onViewController:);
        else if (to == 0)
            selector = @selector(_forwardViewDidDisappear:onViewController:);
    }
    
    [self doForControllers:^(UIViewController *controller, IIViewDeckSide side) {
        if (from < to && _sideAppeared[side] <= from)
            return;
        else if (from > to && _sideAppeared[side] >= from)
            return;
    }];
}



#pragma mark - controller state

-(void)setCenterhiddenInteractivity:(IIViewDeckCenterHiddenInteractivity)centerhiddenInteractivity {
    _centerhiddenInteractivity = centerhiddenInteractivity;
    
    if ([self isAnySideOpen]) {
        if (IIViewDeckCenterHiddenIsInteractive(self.centerhiddenInteractivity)) {
            [self centerViewVisible];
        } else {
            [self centerViewHidden];
        }
    }
}

- (BOOL)isSideClosed:(IIViewDeckSide)viewDeckSide {
    if (![self controllerForSide:viewDeckSide])
        return YES;
    
    switch (viewDeckSide) {
        case IIViewDeckLeftSide:
            return CGRectGetMinX(self.slidingControllerView.frame) <= 0;
            
        case IIViewDeckRightSide:
            return CGRectGetMaxX(self.slidingControllerView.frame) >= self.referenceBounds.size.width;
            
        default:
            return YES;
    }
}


- (BOOL)isAnySideOpen {
    return [self isSideOpen:IIViewDeckLeftSide] || [self isSideOpen:IIViewDeckRightSide];
}


- (BOOL)isSideOpen:(IIViewDeckSide)viewDeckSide {
    if (![self controllerForSide:viewDeckSide])
        return NO;
    
    switch (viewDeckSide) {
        case IIViewDeckLeftSide:
            return II_FLOAT_EQUAL(CGRectGetMinX(self.slidingControllerView.frame), self.referenceBounds.size.width - _ledge[IIViewDeckLeftSide]);
            
        case IIViewDeckRightSide: {
            return II_FLOAT_EQUAL(CGRectGetMaxX(self.slidingControllerView.frame), _ledge[IIViewDeckRightSide]);
        }

        default:
            return NO;
    }
}

- (BOOL)isSideTransitioning:(IIViewDeckSide)viewDeckSide {
    return ![self isSideClosed:viewDeckSide] && ![self isSideOpen:viewDeckSide];
}

- (BOOL)openSideView:(IIViewDeckSide)side animated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self openSideView:side animated:animated duration:DEFAULT_DURATION completion:completed];
}

- (BOOL)openSideView:(IIViewDeckSide)side animated:(BOOL)animated duration:(NSTimeInterval)duration completion:(IIViewDeckControllerBlock)completed {
    // if there's no controller or we're already open, just run the completion and say we're done.
    if (![self controllerForSide:side] || [self isSideOpen:side]) {
        if (completed) completed(self, YES);
        return YES;
    }
    
    // check the delegate to allow opening
    if (![self checkCanOpenSide:side]) {
        if (completed) completed(self, NO);
        return NO;
    };
    
    if (![self isSideClosed:[self oppositeOfSide:side]]) {
        return [self toggleOpenViewAnimated:animated completion:completed];
    }
    
    if (duration == DEFAULT_DURATION) duration = [self openSlideDuration:animated];
    
    __block UIViewAnimationOptions options = UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState;
    
    IIViewDeckControllerBlock finish = ^(IIViewDeckController *controller, BOOL success) {
        if (!success) {
            if (completed) completed(self, NO);
            return;
        }
        
        [self notifyWillOpenSide:side animated:animated];
        [self disableUserInteraction];
        [UIView animateWithDuration:duration delay:0 options:options animations:^{
            [self hide:NO controllerViewForSide:side];
//            [self setSlidingFrameForOffset:[self ledgeOffsetForSide:side] forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES];
            [self centerViewHidden];
        } completion:^(BOOL finished) {
            [self enableUserInteraction];
            [self setAccessibilityForCenterTapper]; // update since the frame and the frame's intersection with the window will have changed
            if (completed) completed(self, YES);
            [self notifyDidOpenSide:side animated:animated];
            UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
        }];
    };
    
    if ([self isSideClosed:side]) {
        // try to close any open view first
        return [self closeOpenViewAnimated:animated completion:finish];
    }
    else {
        options |= UIViewAnimationOptionCurveEaseOut;

        finish(self, YES);
        return YES;
    }
}

- (void)hide:(BOOL)hidden controllerViewForSide:(IIViewDeckSide)side  {
//    if ([self sideControllerCount] > 1)
//        [self controllerForSide:side].view.hidden = hidden;
//    else
//        [self controllerForSide:side].view.hidden = NO;
}

- (BOOL)openSideView:(IIViewDeckSide)side bounceOffset:(CGFloat)bounceOffset targetOffset:(CGFloat)targetOffset bounced:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    BOOL animated = YES;
    
    // if there's no controller or we're already open, just run the completion and say we're done.
    if (![self controllerForSide:side] || [self isSideOpen:side]) {
        if (completed) completed(self, YES);
        return YES;
    }
    
    // check the delegate to allow opening
    if (![self checkCanOpenSide:side]) {
        if (completed) completed(self, NO);
        return NO;
    };
    
    UIViewAnimationOptions options = UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState;
    if ([self isSideClosed:side]) options |= UIViewAnimationOptionCurveEaseIn;

    return [self closeOpenViewAnimated:animated completion:^(IIViewDeckController *controller, BOOL success) {
        if (!success) {
            if (completed) completed(self, NO);
            return;
        }
        
        CGFloat longFactor = _bounceDurationFactor ? _bounceDurationFactor : 1;
        CGFloat shortFactor = _bounceOpenSideDurationFactor ? _bounceOpenSideDurationFactor : (_bounceDurationFactor ? 1-_bounceDurationFactor : 1);
      
        // first open the view completely, run the block (to allow changes)
        [self notifyWillOpenSide:side animated:animated];
        [self disableUserInteraction];
        [UIView animateWithDuration:[self openSlideDuration:YES]*longFactor delay:0 options:options animations:^{
            [self hide:NO controllerViewForSide:side];
//            [self setSlidingFrameForOffset:bounceOffset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES];
        } completion:^(BOOL finished) {
            [self centerViewHidden];
            // run block if it's defined
            if (bounced) bounced(self);
            [self performDelegate:@selector(viewDeckController:didBounceViewSide:openingController:) side:side controller:_controllers[side]];
            
            // now slide the view back to the ledge position
            [UIView animateWithDuration:[self openSlideDuration:YES]*shortFactor delay:0 options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState animations:^{
//                [self setSlidingFrameForOffset:targetOffset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES];
            } completion:^(BOOL finished2) {
                [self enableUserInteraction];
                [self setAccessibilityForCenterTapper]; // update since the frame and the frame's intersection with the window will have changed
                if (completed) completed(self, YES);
                [self notifyDidOpenSide:side animated:animated];
                UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
            }];
        }];
    }];
}


- (BOOL)closeSideView:(IIViewDeckSide)side animated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self closeSideView:side animated:animated duration:DEFAULT_DURATION completion:completed];
}

- (BOOL)closeSideView:(IIViewDeckSide)side animated:(BOOL)animated duration:(NSTimeInterval)duration completion:(IIViewDeckControllerBlock)completed {
    if ([self isSideClosed:side]) {
        if (completed) completed(self, YES);
        return YES;
    }
    
    // check the delegate to allow closing
    if (![self checkCanCloseSide:side]) {
        if (completed) completed(self, NO);
        return NO;
    }
    
    if (duration == DEFAULT_DURATION) duration = [self closeSlideDuration:animated];
    
    UIViewAnimationOptions options = UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState;
    options |= [self isSideOpen:side] ? UIViewAnimationOptionCurveEaseInOut : UIViewAnimationOptionCurveEaseOut;
    
    [self notifyWillCloseSide:side animated:animated];
    [self disableUserInteraction];
    [UIView animateWithDuration:duration delay:0 options:options animations:^{
//        [self setSlidingFrameForOffset:0 forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:animated];
        [self centerViewVisible];
    } completion:^(BOOL finished) {
//        [self hideAppropriateSideViews];
        [self enableUserInteraction];
        if (completed) completed(self, YES);
        [self notifyDidCloseSide:side animated:animated];
        UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
    }];
    
    return YES;
}

- (CGFloat)openSlideDuration:(BOOL)animated {
    return animated ? self.openSlideAnimationDuration : 0;
}

- (CGFloat)closeSlideDuration:(BOOL)animated {
    return animated ? self.closeSlideAnimationDuration : 0;
}


- (BOOL)closeSideView:(IIViewDeckSide)side bounceOffset:(CGFloat)bounceOffset bounced:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    if ([self isSideClosed:side]) {
        if (completed) completed(self, YES);
        return YES;
    }
    
    // check the delegate to allow closing
    if (![self checkCanCloseSide:side]) {
        if (completed) completed(self, NO);
        return NO;
    }
    
    UIViewAnimationOptions options = UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState;
    if ([self isSideOpen:side]) options |= UIViewAnimationOptionCurveEaseIn;
    
    BOOL animated = YES;
    
    CGFloat longFactor = _bounceDurationFactor ? _bounceDurationFactor : 1;
    CGFloat shortFactor = _bounceOpenSideDurationFactor ? _bounceOpenSideDurationFactor : (_bounceDurationFactor ? 1-_bounceDurationFactor : 1);
  
    // first open the view completely, run the block (to allow changes) and close it again.
    [self notifyWillCloseSide:side animated:animated];
    [self disableUserInteraction];
    [UIView animateWithDuration:[self openSlideDuration:YES]*shortFactor delay:0 options:options animations:^{
//        [self setSlidingFrameForOffset:bounceOffset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES];
    } completion:^(BOOL finished) {
        // run block if it's defined
        if (bounced) bounced(self);
        [self performDelegate:@selector(viewDeckController:didBounceViewSide:closingController:) side:side controller:_controllers[side]];
        
        [UIView animateWithDuration:[self closeSlideDuration:YES]*longFactor delay:0 options:UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionLayoutSubviews animations:^{
//            [self setSlidingFrameForOffset:0 forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(side) animated:YES];
            [self centerViewVisible];
        } completion:^(BOOL finished2) {
//            [self hideAppropriateSideViews];
            [self enableUserInteraction];
            if (completed) completed(self, YES);
            [self notifyDidCloseSide:side animated:animated];
            UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, nil);
        }];
    }];
    
    return YES;
}


#pragma mark - Left Side

- (BOOL)toggleLeftView {
    return [self toggleLeftViewAnimated:YES];
}

- (BOOL)openLeftView {
    return [self openLeftViewAnimated:YES];
}

- (BOOL)closeLeftView {
    return [self closeLeftViewAnimated:YES];
}

- (BOOL)toggleLeftViewAnimated:(BOOL)animated {
    return [self toggleLeftViewAnimated:animated completion:nil];
}

- (BOOL)toggleLeftViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    if ([self isSideClosed:IIViewDeckLeftSide]) 
        return [self openLeftViewAnimated:animated completion:completed];
    else
        return [self closeLeftViewAnimated:animated completion:completed];
}

- (BOOL)openLeftViewAnimated:(BOOL)animated {
    return [self openLeftViewAnimated:animated completion:nil];
}

- (BOOL)openLeftViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self openSideView:IIViewDeckLeftSide animated:animated completion:completed];
}

- (BOOL)openLeftViewBouncing:(IIViewDeckControllerBounceBlock)bounced {
    return [self openLeftViewBouncing:bounced completion:nil];
}

- (BOOL)openLeftViewBouncing:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    return [self openSideView:IIViewDeckLeftSide bounceOffset:self.referenceBounds.size.width targetOffset:self.referenceBounds.size.width - _ledge[IIViewDeckLeftSide] bounced:bounced completion:completed];
}

- (BOOL)closeLeftViewAnimated:(BOOL)animated {
    return [self closeLeftViewAnimated:animated completion:nil];
}

- (BOOL)closeLeftViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self closeLeftViewAnimated:animated duration:DEFAULT_DURATION completion:completed];
}

- (BOOL)closeLeftViewAnimated:(BOOL)animated duration:(NSTimeInterval)duration completion:(IIViewDeckControllerBlock)completed {
    return [self closeSideView:IIViewDeckLeftSide animated:animated duration:duration completion:completed];
}

- (BOOL)closeLeftViewBouncing:(IIViewDeckControllerBounceBlock)bounced {
    return [self closeLeftViewBouncing:bounced completion:nil];
}

- (BOOL)closeLeftViewBouncing:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    return [self closeSideView:IIViewDeckLeftSide bounceOffset:self.referenceBounds.size.width bounced:bounced completion:completed];
}

#pragma mark - Right Side

- (BOOL)toggleRightView {
    return [self toggleRightViewAnimated:YES];
}

- (BOOL)openRightView {
    return [self openRightViewAnimated:YES];
}

- (BOOL)closeRightView {
    return [self closeRightViewAnimated:YES];
}

- (BOOL)toggleRightViewAnimated:(BOOL)animated {
    return [self toggleRightViewAnimated:animated completion:nil];
}

- (BOOL)toggleRightViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    if ([self isSideClosed:IIViewDeckRightSide]) 
        return [self openRightViewAnimated:animated completion:completed];
    else
        return [self closeRightViewAnimated:animated completion:completed];
}

- (BOOL)openRightViewAnimated:(BOOL)animated {
    return [self openRightViewAnimated:animated completion:nil];
}

- (BOOL)openRightViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self openSideView:IIViewDeckRightSide animated:animated completion:completed];
}

- (BOOL)openRightViewBouncing:(IIViewDeckControllerBounceBlock)bounced {
    return [self openRightViewBouncing:bounced completion:nil];
}

- (BOOL)openRightViewBouncing:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    return [self openSideView:IIViewDeckRightSide bounceOffset:-self.referenceBounds.size.width targetOffset:_ledge[IIViewDeckRightSide] - self.referenceBounds.size.width bounced:bounced completion:completed];
}

- (BOOL)closeRightViewAnimated:(BOOL)animated {
    return [self closeRightViewAnimated:animated completion:nil];
}

- (BOOL)closeRightViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self closeRightViewAnimated:animated duration:DEFAULT_DURATION completion:completed];
}

- (BOOL)closeRightViewAnimated:(BOOL)animated duration:(NSTimeInterval)duration completion:(IIViewDeckControllerBlock)completed {
    return [self closeSideView:IIViewDeckRightSide animated:animated duration:duration completion:completed];
}

- (BOOL)closeRightViewBouncing:(IIViewDeckControllerBounceBlock)bounced {
    return [self closeRightViewBouncing:bounced completion:nil];
}

- (BOOL)closeRightViewBouncing:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    return [self closeSideView:IIViewDeckRightSide bounceOffset:-self.referenceBounds.size.width bounced:bounced completion:completed];
}

#pragma mark - right view, special case for navigation stuff

- (BOOL)canRightViewPushViewControllerOverCenterController {
    return [self.centerController isKindOfClass:[UINavigationController class]];
}

- (void)rightViewPushViewControllerOverCenterController:(UIViewController*)controller {
    NSAssert([self.centerController isKindOfClass:[UINavigationController class]], @"cannot rightViewPushViewControllerOverCenterView when center controller is not a navigation controller");

    UIView* view = self.view;
    UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);

    CGContextRef context = UIGraphicsGetCurrentContext();
    [view.layer renderInContext:context];
    UIImage *deckshot = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    UIImageView* shotView = [[UIImageView alloc] initWithImage:deckshot];
    shotView.frame = view.frame; 
    [view.superview addSubview:shotView];
    CGRect targetFrame = view.frame; 
    view.frame = CGRectOffset(view.frame, view.frame.size.width, 0);
    
    [self closeRightViewAnimated:NO];
    UINavigationController* navController = self.centerController.navigationController ? self.centerController.navigationController :(UINavigationController*)self.centerController;
    [navController pushViewController:controller animated:NO];
    
    [self disableUserInteraction];
    [UIView animateWithDuration:0.3 delay:0 options:0 animations:^{
        shotView.frame = CGRectOffset(shotView.frame, -view.frame.size.width, 0);
        view.frame = targetFrame;
    } completion:^(BOOL finished) {
        [self enableUserInteraction];
        [shotView removeFromSuperview];
    }];
}

#pragma mark - disable pan over certain controllers

- (void)disablePanOverViewsOfClass:(Class)viewClass {
    if (viewClass)
        [_disabledPanClasses addObject:viewClass];
}

- (void)enablePanOverViewsOfClass:(Class)viewClass {
    if (viewClass)
        [_disabledPanClasses removeObject:viewClass];
}

- (BOOL)canPanOverViewsOfClass:(Class)viewClass {
    if (viewClass)
        return [_disabledPanClasses containsObject:viewClass];
    else
        return NO;
}

- (NSArray*)viewClassesWithDisabledPan {
    return [_disabledPanClasses allObjects];
}



#pragma mark - Side Bouncing

- (BOOL)previewBounceView:(IIViewDeckSide)viewDeckSide {
    return [self previewBounceView:viewDeckSide withCompletion:nil];
}

- (BOOL)previewBounceView:(IIViewDeckSide)viewDeckSide withCompletion:(IIViewDeckControllerBlock)completed {
    return [self previewBounceView:viewDeckSide toDistance:40.0f duration:1.2f callDelegate:YES completion:completed];
}

- (BOOL)previewBounceView:(IIViewDeckSide)viewDeckSide toDistance:(CGFloat)distance duration:(NSTimeInterval)duration callDelegate:(BOOL)callDelegate completion:(IIViewDeckControllerBlock)completed {
    return [self previewBounceView:viewDeckSide toDistance:distance duration:duration numberOfBounces:4.0f dampingFactor:0.40f callDelegate:callDelegate completion:completed];
}

- (BOOL)previewBounceView:(IIViewDeckSide)viewDeckSide toDistance:(CGFloat)distance duration:(NSTimeInterval)duration numberOfBounces:(CGFloat)numberOfBounces dampingFactor:(CGFloat)zeta callDelegate:(BOOL)callDelegate completion:(IIViewDeckControllerBlock)completed {
    // Check if the requested side to bounce is nil, or if it's already open
    if (![self controllerForSide:viewDeckSide] || [self isSideOpen:viewDeckSide]) return NO;
    
    // check the delegate to allow bouncing
    if (callDelegate && ![self checkDelegate:@selector(viewDeckController:shouldPreviewBounceViewSide:) side:viewDeckSide]) return NO;
    // also close any view that's open. Since the delegate can cancel the close, check the result.
    if (callDelegate && [self isAnySideOpen]) {
        if (![self toggleOpenViewAnimated:YES]) return NO;
    }
    // check for in-flight preview bounce animation, do not add another if so
    if ([self.slidingControllerView.layer animationForKey:@"previewBounceAnimation"]) {
        return NO;
    }
    
    NSArray *animationValues = [self bouncingValuesForViewSide:viewDeckSide maximumBounce:distance numberOfBounces:numberOfBounces dampingFactor:zeta duration:duration];
    if (!animationValues) {
        return NO;
    }
    
    UIViewController *previewController = [self controllerForSide:viewDeckSide];
    NSString *keyPath = @"position.x";
    
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:keyPath];
    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
    animation.duration = duration;
    animation.values = animationValues;
    animation.removedOnCompletion = YES;
    
    previewController.view.hidden = NO;
    
    [CATransaction begin];
    [CATransaction setValue:[NSNumber numberWithFloat:duration] forKey:kCATransactionAnimationDuration];
    [CATransaction setCompletionBlock:^{
        // only re-hide controller if the view has not been panned mid-animation
        if (_offset == 0.0f) {
            previewController.view.hidden = YES;
        }
        
        // perform completion and delegate call
        if (completed) completed(self, YES);
        if (callDelegate) [self performDelegate:@selector(viewDeckController:didPreviewBounceViewSide:animated:) side:viewDeckSide animated:YES];
    }];
    [self.slidingControllerView.layer addAnimation:animation forKey:@"previewBounceAnimation"];
    
    // Inform delegate
    if (callDelegate) [self performDelegate:@selector(viewDeckController:willPreviewBounceViewSide:animated:) side:viewDeckSide animated:YES];
    
    // Commit animation
    [CATransaction commit];
    
    return YES;
}

- (NSArray *)bouncingValuesForViewSide:(IIViewDeckSide)viewDeckSide maximumBounce:(CGFloat)maxBounce numberOfBounces:(CGFloat)numberOfBounces dampingFactor:(CGFloat)zeta duration:(NSTimeInterval)duration {
    
    // Underdamped, Free Vibration of a SDOF System
    // u(t) = abs(e^(-zeta * wn * t) * ((Vo/wd) * sin(wd * t))
    
    // Vo, initial velocity, is calculated to provide the desired maxBounce and
    // animation duration. The damped period (wd) and distance of the maximum (first)
    // bounce can be controlled either via the initial condition Vo or the damping
    // factor zeta for a desired duration, Vo is simpler mathematically.
    
    NSUInteger steps = (NSUInteger)MIN(floorf(duration * 100.0f), 100);
    float time = 0.0;
    
    NSMutableArray *values = [NSMutableArray arrayWithCapacity:steps];
    
    double offset = 0.0;
    float Td = (2.0f * duration) / numberOfBounces; //Damped period, calculated to give the number of bounces desired in the duration specified (2 bounces per Td)
    float wd = (2.0f * M_PI)/Td; // Damped frequency
    zeta = MAX(0.0001f, zeta);
    zeta = MIN(zeta, 0.9999f); // For an underdamped system, we must have 0 < zeta < 1
    float zetaFactor = sqrtf(1 - powf(zeta, 2.0f)); // Used in multiple places
    float wn = wd/zetaFactor; // Natural frequency
    float Vo = maxBounce * wd/(expf(-zeta/zetaFactor * (0.18f * Td) * wd) * sinf(0.18f * Td * wd));
    
    // Determine parameters based on direction
    CGFloat position = 0.0f;
    NSInteger direction = 1;
    switch (viewDeckSide) {
        case IIViewDeckLeftSide:
            position = self.slidingControllerView.layer.position.x;
            direction = 1;
            break;
            
        case IIViewDeckRightSide:
            position = self.slidingControllerView.layer.position.x;
            direction = -1;
            break;
        
        default:
            return nil;
            break;
    }
    
    // Calculate steps
    for (uint t = 0; t < steps; t++) {
        time = (t / (float)steps) * duration;
        offset = ABS(expf(-zeta * wn * time) * ((Vo / wd) * sin(wd * time)));
//        offset = direction * [self limitOffset:offset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(viewDeckSide)] + position;
        [values addObject:[NSNumber numberWithFloat:offset]];
    }
    
    return values;
}

#pragma mark - toggling open view

- (BOOL)toggleOpenView {
    return [self toggleOpenViewAnimated:YES];
}

- (BOOL)toggleOpenViewAnimated:(BOOL)animated {
    return [self toggleOpenViewAnimated:animated completion:nil];
}

- (BOOL)toggleOpenViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    IIViewDeckSide fromSide, toSide;
    CGFloat targetOffset;
    
    if ([self isSideOpen:IIViewDeckLeftSide]) {
        fromSide = IIViewDeckLeftSide;
        toSide = IIViewDeckRightSide;
        targetOffset = _ledge[IIViewDeckRightSide] - self.referenceBounds.size.width;
    }
    else if (([self isSideOpen:IIViewDeckRightSide])) {
        fromSide = IIViewDeckRightSide;
        toSide = IIViewDeckLeftSide;
        targetOffset = self.referenceBounds.size.width - _ledge[IIViewDeckLeftSide];
    }
    else
        return NO;

    // check the delegate to allow closing and opening
    if (![self checkCanCloseSide:fromSide] && ![self checkCanOpenSide:toSide]) return NO;
    
    [self notifyWillCloseSide:fromSide animated:animated];
    [UIView animateWithDuration:[self closeSlideDuration:animated] delay:0 options:UIViewAnimationOptionCurveEaseIn | UIViewAnimationOptionLayoutSubviews animations:^{
//        [self setSlidingFrameForOffset:0 forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(fromSide) animated:YES];
    } completion:^(BOOL finished) {
        [self notifyWillOpenSide:toSide animated:animated];
        [UIView animateWithDuration:[self openSlideDuration:animated] delay:0 options:UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionLayoutSubviews animations:^{
//            [self setSlidingFrameForOffset:targetOffset forOrientation:IIViewDeckOffsetOrientationFromIIViewDeckSide(toSide) animated:YES];
        } completion:^(BOOL finished2) {
            [self notifyDidOpenSide:toSide animated:animated];
        }];
//        [self hideAppropriateSideViews];
        [self notifyDidCloseSide:fromSide animated:animated];
    }];
    
    return YES;
}


- (BOOL)closeOpenView {
    return [self closeOpenViewAnimated:YES];
}

- (BOOL)closeOpenViewAnimated:(BOOL)animated {
    return [self closeOpenViewAnimated:animated completion:nil];
}

- (BOOL)closeOpenViewAnimated:(BOOL)animated completion:(IIViewDeckControllerBlock)completed {
    return [self closeOpenViewAnimated:animated duration:DEFAULT_DURATION completion:completed];
}

- (BOOL)closeOpenViewAnimated:(BOOL)animated duration:(NSTimeInterval)duration completion:(IIViewDeckControllerBlock)completed {
    if (![self isSideClosed:IIViewDeckLeftSide]) {
        return [self closeLeftViewAnimated:animated duration:duration completion:completed];
    }
    else if (![self isSideClosed:IIViewDeckRightSide]) {
        return [self closeRightViewAnimated:animated duration:duration completion:completed];
    }
    
    if (completed) completed(self, YES);
    return YES;
}


- (BOOL)closeOpenViewBouncing:(IIViewDeckControllerBounceBlock)bounced {
    return [self closeOpenViewBouncing:bounced completion:nil];
}

- (BOOL)closeOpenViewBouncing:(IIViewDeckControllerBounceBlock)bounced completion:(IIViewDeckControllerBlock)completed {
    if ([self isSideOpen:IIViewDeckLeftSide]) {
        return [self closeLeftViewBouncing:bounced completion:completed];
    }
    else if (([self isSideOpen:IIViewDeckRightSide])) {
        return [self closeRightViewBouncing:bounced completion:completed];
    }
    
    if (completed) completed(self, YES);
    return YES;
}

#pragma mark - center view hidden stuff

- (void)centerViewVisible {
    if (self.centerTapper) {
        [self.centerTapper removeTarget:self action:@selector(centerTapped) forControlEvents:UIControlEventTouchUpInside];
        [self.centerTapper removeFromSuperview];
    }
    self.centerTapper = nil;
    [self setNeedsAddPanners];
    [self applyShadowToSlidingViewAnimated:YES];
}

- (void)centerViewHidden {
    if (!IIViewDeckCenterHiddenIsInteractive(self.centerhiddenInteractivity)) {
        if (!self.centerTapper) {
            self.centerTapper = [UIButton buttonWithType:UIButtonTypeCustom];
            [self.centerTapper setBackgroundImage:nil forState:UIControlStateNormal];
            [self.centerTapper setBackgroundImage:nil forState:UIControlStateHighlighted];
            [self.centerTapper setBackgroundImage:nil forState:UIControlStateDisabled];
            self.centerTapper.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
            self.centerTapper.frame = [self.centerView bounds];
            [self.centerTapper addTarget:self action:@selector(centerTapped) forControlEvents:UIControlEventTouchUpInside];
            self.centerTapper.backgroundColor = [UIColor clearColor];
            if ([self.centerTapper respondsToSelector:@selector(accessibilityViewIsModal)]) {
				self.centerTapper.accessibilityViewIsModal = YES;
			}
        }
        [self.centerView addSubview:self.centerTapper];
        self.centerTapper.frame = [self.centerView bounds];
        [self setAccessibilityForCenterTapper]; // set accessibility label, hint, and frame
        
        [self setNeedsAddPanners];
    }
    
    [self applyShadowToSlidingViewAnimated:YES];
}

- (void)centerTapped {
    if (IIViewDeckCenterHiddenCanTapToClose(self.centerhiddenInteractivity)) {
        if (self.leftController && CGRectGetMinX(self.slidingControllerView.frame) > 0) {
            if (self.centerhiddenInteractivity == IIViewDeckCenterHiddenNotUserInteractiveWithTapToClose) 
                [self closeLeftView];
            else
                [self closeLeftViewBouncing:nil];
        }
        if (self.rightController && CGRectGetMinX(self.slidingControllerView.frame) < 0) {
            if (self.centerhiddenInteractivity == IIViewDeckCenterHiddenNotUserInteractiveWithTapToClose) 
                [self closeRightView];
            else
                [self closeRightViewBouncing:nil];
        }
    }
}

- (void)disableUserInteraction {
    @synchronized (self.view) {
        ++_disabledUserInteractions;
        if (_disabledUserInteractions == 1) {
            ((IIViewDeckView*)self.view).allowUserInteractionEnabled = NO;
        }
    }
}

- (void)enableUserInteraction {
    @synchronized (self.view) {
        if (_disabledUserInteractions > 0) {
            --_disabledUserInteractions;
            if (_disabledUserInteractions == 0) {
                ((IIViewDeckView*)self.view).allowUserInteractionEnabled = YES;
            }
        }
    }
}

- (void)setAccessibilityForCenterTapper {
    if (self.centerTapper) {
        self.centerTapper.accessibilityLabel = self.centerTapperAccessibilityLabel;
        self.centerTapper.accessibilityHint = self.centerTapperAccessibilityHint;
        self.centerTapper.accessibilityFrame = CGRectIntersection(self.view.window.bounds, [self.centerTapper convertRect:self.centerTapper.bounds toView:nil]);
    }
}

- (void)setCenterTapperAccessibilityLabel:(NSString *)centerTapperAccessibilityLabel {
    if (![_centerTapperAccessibilityLabel isEqualToString:centerTapperAccessibilityLabel]) {
        _centerTapperAccessibilityLabel = centerTapperAccessibilityLabel;
        [self setAccessibilityForCenterTapper];
    }
}

- (void)setCenterTapperAccessibilityHint:(NSString *)centerTapperAccessibilityHint {
    if (![_centerTapperAccessibilityHint isEqualToString:centerTapperAccessibilityHint]) {
        _centerTapperAccessibilityHint = centerTapperAccessibilityHint;
        [self setAccessibilityForCenterTapper];
    }
}

#pragma mark - Panning

- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)panner {
    UINavigationController* navController = [self.centerController isKindOfClass:[UINavigationController class]] ? (UINavigationController*)self.centerController : self.centerController.navigationController;

    if (self.panningMode == IIViewDeckNavigationBarOrOpenCenterPanning && panner.view == self.slidingControllerView) {
        CGPoint loc = [panner locationInView:navController.navigationBar];
        
        if (!CGRectContainsPoint(navController.navigationBar.bounds, loc) && ![self isAnySideOpen])
            return NO;
    }
    
    if (self.panningGestureDelegate && [self.panningGestureDelegate respondsToSelector:@selector(gestureRecognizerShouldBegin:)]) {
        BOOL result = [self.panningGestureDelegate gestureRecognizerShouldBegin:panner];
        if (!result) return result;
    }
    
    CGFloat pv;
    IIViewDeckSide minSide, maxSide;
    minSide = IIViewDeckLeftSide;
    maxSide = IIViewDeckRightSide;
    pv = self.slidingControllerView.frame.origin.x;
    
    if (self.panningMode == IIViewDeckDelegatePanning && [self.delegate respondsToSelector:@selector(viewDeckController:shouldPan:)]) {
        if (![self.delegate viewDeckController:self shouldPan:panner])
            return NO;
    }
    
    if (pv != 0) return YES;
        
    CGFloat v = [self locationOfPanner:panner];
    BOOL ok = YES;

    if (v > 0) {
        ok = [self checkCanOpenSide:minSide];
        if (!ok)
            [self closeSideView:minSide animated:NO completion:nil];
    }
    else if (v < 0) {
        ok = [self checkCanOpenSide:maxSide];
        if (!ok)
            [self closeSideView:maxSide animated:NO completion:nil];
    }
    
    return ok;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {
    // allow the panningGestureDelegate to act first
    if (self.panningGestureDelegate && [self.panningGestureDelegate respondsToSelector:@selector(gestureRecognizer:shouldReceiveTouch:)]) {
        BOOL result = [self.panningGestureDelegate gestureRecognizer:gestureRecognizer
                                                  shouldReceiveTouch:touch];
        if (!result) return result;
    }
    
    // check the disabled pan classes
    for (Class viewClass in _disabledPanClasses) {
        if ([[touch view] isKindOfClass:viewClass])
            return NO;
    }

    // check the delegate if we should start panning over this view
    if (![self checkDelegate:@selector(viewDeckController:shouldBeginPanOverView:) view:[touch view]]) {
        return NO;
    }

    _panOrigin = self.slidingControllerView.frame.origin;
    return YES;
}

-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer {
    if (self.panningGestureDelegate && [self.panningGestureDelegate respondsToSelector:@selector(gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:)]) {
        return [self.panningGestureDelegate gestureRecognizer:gestureRecognizer
           shouldRecognizeSimultaneouslyWithGestureRecognizer:otherGestureRecognizer];
    }
    
    return NO;
}

- (CGFloat)locationOfPanner:(UIPanGestureRecognizer*)panner {
    CGPoint pan = [panner translationInView:self.referenceView];
    CGFloat ofs = pan.x + _panOrigin.x;
    
    IIViewDeckSide minSide, maxSide;
    CGFloat max;
    minSide = IIViewDeckLeftSide;
    maxSide = IIViewDeckRightSide;
    max = self.referenceBounds.size.width;

    if (!_controllers[minSide]) ofs = MIN(0, ofs);
    if (!_controllers[maxSide]) ofs = MAX(0, ofs);
    
    CGFloat lofs = MIN(ofs, max-_ledge[minSide]);
    lofs = MAX(lofs, -max+_ledge[maxSide]);
    
    if (self.elastic) {
        CGFloat dofs = ABS(ofs) - ABS(lofs);
        if (dofs > 0) {
            dofs = dofs / logf(dofs + 1) * 2;
            ofs = lofs + (ofs < 0 ? -dofs : dofs);
        }
    }
    else {
        ofs = lofs;
    }
    
    return 0.0;//[self limitOffset:ofs forOrientation:orientation];
}


- (void)panned:(UIPanGestureRecognizer*)panner {
    if (!_enabled) return;
    
    [self setParallax];
    
    CGFloat pv, m;
    IIViewDeckSide minSide, maxSide;
    pv = self.slidingControllerView.frame.origin.x;
    m = self.referenceBounds.size.width;
    minSide = IIViewDeckLeftSide;
    maxSide = IIViewDeckRightSide;
    
    CGFloat v = [self locationOfPanner:panner];

    IIViewDeckSide closeSide = IIViewDeckNoSide;
    IIViewDeckSide openSide = IIViewDeckNoSide;
    
    // if we move over a boundary while dragging, ... 
    if (pv <= 0 && v >= 0 && pv != v) {
        // ... then we need to check if the other side can open.
        if (pv < 0) {
            if (![self checkCanCloseSide:maxSide])
                return;
            [self notifyWillCloseSide:maxSide animated:NO];
            closeSide = maxSide;
        }

        if (v > 0) {
            if (![self checkCanOpenSide:minSide]) {
                [self closeSideView:maxSide animated:NO completion:nil];
                return;
            }
            [self notifyWillOpenSide:minSide animated:NO];
            openSide = minSide;
        }
    }
    else if (pv >= 0 && v <= 0 && pv != v) {
        if (pv > 0) {
            if (![self checkCanCloseSide:minSide])
                return;
            [self notifyWillCloseSide:minSide animated:NO];
            closeSide = minSide;
        }

        if (v < 0) {
            if (![self checkCanOpenSide:maxSide]) {
                [self closeSideView:minSide animated:NO completion:nil];
                return;
            }
            [self notifyWillOpenSide:maxSide animated:NO];
            openSide = maxSide;
        }
    }
    
    // Check for an in-flight bounce animation
    CAKeyframeAnimation *bounceAnimation = (CAKeyframeAnimation *)[self.slidingControllerView.layer animationForKey:@"previewBounceAnimation"];
    if (bounceAnimation != nil) {
        self.slidingControllerView.frame = [[self.slidingControllerView.layer presentationLayer] frame];
        [self.slidingControllerView.layer removeAnimationForKey:@"previewBounceAnimation"];
        [UIView animateWithDuration:0.3 delay:0 options:UIViewAnimationOptionLayoutSubviews | UIViewAnimationOptionBeginFromCurrentState animations:^{
//            [self panToSlidingFrameForOffset:v forOrientation:orientation animated:YES];
        } completion:nil];
    } else {
//        [self panToSlidingFrameForOffset:v forOrientation:orientation animated:NO];
    }
    
    if (panner.state == UIGestureRecognizerStateEnded ||
        panner.state == UIGestureRecognizerStateCancelled ||
        panner.state == UIGestureRecognizerStateFailed) {
        CGFloat sv = self.slidingControllerView.frame.origin.x;
        if (II_FLOAT_EQUAL(sv, 0.0f))
            [self centerViewVisible];
        else
            [self centerViewHidden];
        
        CGFloat lm3 = (m-_ledge[minSide]) / 3.0;
        CGFloat rm3 = (m-_ledge[maxSide]) / 3.0;
        CGPoint velocity = [panner velocityInView:self.referenceView];
        CGFloat orientationVelocity = velocity.x;
        if (ABS(orientationVelocity) < 500) {
            // small velocity, no movement
            if (v >= m - _ledge[minSide] - lm3) {
                [self openSideView:minSide animated:YES completion:nil];
            }
            else if (v <= _ledge[maxSide] + rm3 - m) {
                [self openSideView:maxSide animated:YES completion:nil];
            }
            else
                [self closeOpenView];
        }
        else if (orientationVelocity != 0.0f) {
            if (orientationVelocity < 0) {
                // swipe to the left
                // Animation duration based on velocity
                CGFloat pointsToAnimate = self.slidingControllerView.frame.origin.x;
                NSTimeInterval animationDuration = ABS(durationToAnimate(pointsToAnimate, orientationVelocity));
                
                if (v < 0) {
                    [self openSideView:maxSide animated:YES duration:animationDuration completion:nil];
                }
                else
                {
                    [self closeOpenViewAnimated:YES duration:animationDuration completion:nil];
                }
            }
            else if (orientationVelocity > 0) {
                // swipe to the right
                
                // Animation duration based on velocity
                CGFloat maxDistance = CGRectGetWidth(self.view.frame) - self.leftSize;
                CGFloat pointsToAnimate = ABS(maxDistance - self.slidingControllerView.frame.origin.x);
                NSTimeInterval animationDuration = durationToAnimate(pointsToAnimate, orientationVelocity);
                
                if (v > 0) {
                    [self openSideView:minSide animated:YES duration:animationDuration completion:nil];
                }
                else 
                    [self closeOpenViewAnimated:YES duration:animationDuration completion:nil];
            }
        }
    }
    else {
//        [self hideAppropriateSideViews];
    }
    
    [self setAccessibilityForCenterTapper]; // update since the frame and the frame's intersection with the window will have changed
    
    [self notifyDidCloseSide:closeSide animated:NO];
    [self notifyDidOpenSide:openSide animated:NO];
    [self addPannersIfAllPannersAreInactiveAndNeeded];
}

- (void) setParallax {
    if(_parallaxAmount <= 0.0) return;
    
    self.leftController.view.frame = [self getLeftParallax];
    self.rightController.view.frame = [self getRightParallax];
}

- (CGRect) getLeftParallax {
    CGFloat pv = self.slidingControllerView.frame.origin.x;
    CGFloat diff = pv-(self.slidingControllerView.frame.size.width-_ledge[IIViewDeckLeftSide]);
    if (diff > 0.0f) diff = 0.0f;
    
    return CGRectMake(diff*_parallaxAmount, self.leftController.view.frame.origin.y, self.leftController.view.frame.size.width, self.leftController.view.frame.size.height);
}

- (CGRect) getRightParallax {
    CGFloat pv = self.slidingControllerView.frame.origin.x;
    CGFloat diff = pv+(self.slidingControllerView.frame.size.width-_ledge[IIViewDeckRightSide]);
    if (diff < 0.0f) diff = 0.0f;
    
    return CGRectMake(diff*_parallaxAmount, self.rightController.view.frame.origin.y, self.rightController.view.frame.size.width, self.rightController.view.frame.size.height);
}


- (void)addPanner:(UIView*)view {
    if (!view) return;
    
    UIPanGestureRecognizer* panner = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panned:)];
    panner.cancelsTouchesInView = _panningCancelsTouchesInView;
    panner.delegate = self;
    [view addGestureRecognizer:panner];
    [self.panners addObject:panner];
}

- (void)setNeedsAddPanners {
    if (_needsAddPannersIfAllPannersAreInactive)
        return;
    if ([self hasActivePanner])
        _needsAddPannersIfAllPannersAreInactive = YES;
    else
        [self addPanners];
}

- (void)addPannersIfAllPannersAreInactiveAndNeeded {
    if (!_needsAddPannersIfAllPannersAreInactive || [self hasActivePanner])
        return;
    [self addPanners];
    _needsAddPannersIfAllPannersAreInactive = NO;
}

- (void)addPanners {
    [self removePanners];
    
    switch (_panningMode) {
        case IIViewDeckNoPanning: 
            break;
            
        case IIViewDeckAllViewsPanning:
            [self addPanner:self.view];
            break;
            
        case IIViewDeckFullViewPanning:
        case IIViewDeckDelegatePanning:
        case IIViewDeckNavigationBarOrOpenCenterPanning:
            [self addPanner:self.slidingControllerView];
            // also add to disabled center
            if (self.centerTapper)
                [self addPanner:self.centerTapper];
            // also add to navigationbar if present
            if (self.navigationController && !self.navigationController.navigationBarHidden) 
                [self addPanner:self.navigationController.navigationBar];
            break;

        case IIViewDeckNavigationBarPanning:
            if (self.navigationController && !self.navigationController.navigationBarHidden) {
                [self addPanner:self.navigationController.navigationBar];
            }
            
            if (self.centerController.navigationController && !self.centerController.navigationController.navigationBarHidden) {
                [self addPanner:self.centerController.navigationController.navigationBar];
            }
            
            if ([self.centerController isKindOfClass:[UINavigationController class]] && !((UINavigationController*)self.centerController).navigationBarHidden) {
                [self addPanner:((UINavigationController*)self.centerController).navigationBar];
            }
            break;
            
        case IIViewDeckPanningViewPanning:
            if (_panningView) {
                [self addPanner:self.panningView];
            }
            break;
    }
}


- (void)removePanners {
    for (UIGestureRecognizer* panner in self.panners) {
        [panner.view removeGestureRecognizer:panner];
        panner.delegate = nil;
    }
    [self.panners removeAllObjects];
}

- (BOOL)hasActivePanner {
    for (UIPanGestureRecognizer *panner in self.panners) {
        if (panner.state == UIGestureRecognizerStateBegan || panner.state == UIGestureRecognizerStateChanged) {
            return YES;
        }
    }
    return NO;
}


#pragma mark - Delegate convenience methods

- (BOOL)checkDelegate:(SEL)selector side:(IIViewDeckSide)viewDeckSide {
    BOOL ok = YES;
    // used typed message send to properly pass values
    BOOL (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, IIViewDeckSide viewDeckSide) = (void*)objc_msgSend;
    
    if (self.delegate && [self.delegate respondsToSelector:selector]) 
        ok = ok & objc_msgSendTyped(self.delegate, selector, self, viewDeckSide);
    
    if (_delegateMode != IIViewDeckDelegateOnly) {
        for (UIViewController* controller in self.controllers) {
            // check controller first
            if ([controller respondsToSelector:selector] && (id)controller != (id)self.delegate)
                ok = ok & objc_msgSendTyped(controller, selector, self, viewDeckSide);
            // if that fails, check if it's a navigation controller and use the top controller
            else if ([controller isKindOfClass:[UINavigationController class]]) {
                UIViewController* topController = ((UINavigationController*)controller).topViewController;
                if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate)
                    ok = ok & objc_msgSendTyped(topController, selector, self, viewDeckSide);
            }
        }
    }
    
    return ok;
}

- (BOOL)checkDelegate:(SEL)selector view:(UIView*)view {
    BOOL ok = YES;
    // used typed message send to properly pass values
    BOOL (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, UIView* view) = (void*)objc_msgSend;
    
    if (self.delegate && [self.delegate respondsToSelector:selector])
        ok = ok & objc_msgSendTyped(self.delegate, selector, self, view);
    
    if (_delegateMode != IIViewDeckDelegateOnly) {
        for (UIViewController* controller in self.controllers) {
            // check controller first
            if ([controller respondsToSelector:selector] && (id)controller != (id)self.delegate)
                ok = ok & objc_msgSendTyped(controller, selector, self, view);
            // if that fails, check if it's a navigation controller and use the top controller
            else if ([controller isKindOfClass:[UINavigationController class]]) {
                UIViewController* topController = ((UINavigationController*)controller).topViewController;
                if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate)
                    ok = ok & objc_msgSendTyped(topController, selector, self, view);
            }
        }
    }
    
    return ok;
}

- (void)performDelegate:(SEL)selector side:(IIViewDeckSide)viewDeckSide animated:(BOOL)animated {
    // used typed message send to properly pass values
    void (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, IIViewDeckSide viewDeckSide, BOOL animated) = (void*)objc_msgSend;
    
    if (self.delegate && [self.delegate respondsToSelector:selector])
        objc_msgSendTyped(self.delegate, selector, self, viewDeckSide, animated);
    
    if (_delegateMode == IIViewDeckDelegateOnly)
        return;
    
    for (UIViewController* controller in self.controllers) {
        // check controller first
        if ([controller respondsToSelector:selector] && (id)controller != (id)self.delegate)
            objc_msgSendTyped(controller, selector, self, viewDeckSide, animated);
        // if that fails, check if it's a navigation controller and use the top controller
        else if ([controller isKindOfClass:[UINavigationController class]]) {
            UIViewController* topController = ((UINavigationController*)controller).topViewController;
            if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate)
                objc_msgSendTyped(topController, selector, self, viewDeckSide, animated);
        }
    }
}

- (void)performDelegate:(SEL)selector side:(IIViewDeckSide)viewDeckSide controller:(UIViewController*)sideController {
    // used typed message send to properly pass values
    void (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, IIViewDeckSide viewDeckSide, UIViewController* controller) = (void*)objc_msgSend;
    
    if (self.delegate && [self.delegate respondsToSelector:selector])
        objc_msgSendTyped(self.delegate, selector, self, viewDeckSide, sideController);
    
    if (_delegateMode == IIViewDeckDelegateOnly)
        return;
    
    for (UIViewController* checkController in self.controllers) {
        // check controller first
        if ([checkController respondsToSelector:selector] && (id)checkController != (id)self.delegate)
            objc_msgSendTyped(checkController, selector, self, viewDeckSide, sideController);
        // if that fails, check if it's a navigation controller and use the top controller
        else if ([checkController isKindOfClass:[UINavigationController class]]) {
            UIViewController* topController = ((UINavigationController*)checkController).topViewController;
            if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate)
                objc_msgSendTyped(topController, selector, self, viewDeckSide, sideController);
        }
    }
}

- (CGFloat)performDelegate:(SEL)selector ledge:(CGFloat)ledge side:(IIViewDeckSide)side {
    CGFloat (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, CGFloat ledge, IIViewDeckSide side) = (void*)objc_msgSend;
    if (self.delegate && [self.delegate respondsToSelector:selector])
        ledge = objc_msgSendTyped(self.delegate, selector, self, ledge, side);
    
    if (_delegateMode == IIViewDeckDelegateOnly)
        return ledge;
    
    for (UIViewController* controller in self.controllers) {
        // check controller first
        if ([controller respondsToSelector:selector] && (id)controller != (id)self.delegate)
            ledge = objc_msgSendTyped(controller, selector, self, ledge, side);
        
        // if that fails, check if it's a navigation controller and use the top controller
        else if ([controller isKindOfClass:[UINavigationController class]]) {
            UIViewController* topController = ((UINavigationController*)controller).topViewController;
            if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate)
                ledge = objc_msgSendTyped(topController, selector, self, ledge, side);
        }
    }
    
    return ledge;
}

- (void)performDelegate:(SEL)selector offset:(CGFloat)offset panning:(BOOL)panning {
    void (*objc_msgSendTyped)(id self, SEL _cmd, IIViewDeckController* foo, CGFloat offset, BOOL panning) = (void*)objc_msgSend;
    if (self.delegate && [self.delegate respondsToSelector:selector]) 
        objc_msgSendTyped(self.delegate, selector, self, offset, panning);
    
    if (_delegateMode == IIViewDeckDelegateOnly)
        return;
    
    for (UIViewController* controller in self.controllers) {
        // check controller first
        if ([controller respondsToSelector:selector] && (id)controller != (id)self.delegate) 
            objc_msgSendTyped(controller, selector, self, offset, panning);
        
        // if that fails, check if it's a navigation controller and use the top controller
        else if ([controller isKindOfClass:[UINavigationController class]]) {
            UIViewController* topController = ((UINavigationController*)controller).topViewController;
            if ([topController respondsToSelector:selector] && (id)topController != (id)self.delegate) 
                objc_msgSendTyped(topController, selector, self, offset, panning);
        }
    }
}


#pragma mark - Properties

- (void)setBounceDurationFactor:(CGFloat)bounceDurationFactor {
    bounceDurationFactor = MIN(bounceDurationFactor, 0.99f);
    _bounceDurationFactor = MAX(0, bounceDurationFactor);
}

- (void)setTitle:(NSString *)title {
    if (!II_STRING_EQUAL(title, self.title)) [super setTitle:title];
    if (!II_STRING_EQUAL(title, self.centerController.title)) self.centerController.title = title;
}

- (NSString*)title {
    return self.centerController.title;
}

- (void)setPanningMode:(IIViewDeckPanningMode)panningMode {
    if (_viewFirstAppeared) {
        _panningMode = panningMode;
        [self setNeedsAddPanners];
    }
    else
        _panningMode = panningMode;
}

- (void)setPanningView:(UIView *)panningView {
    if (_panningView != panningView) {
        _panningView = panningView;
        
        if (_viewFirstAppeared && _panningMode == IIViewDeckPanningViewPanning)
            [self setNeedsAddPanners];
    }
}

- (void)setPanningCancelsTouchesInView:(BOOL)panningCancelsTouchesInView {
    _panningCancelsTouchesInView = panningCancelsTouchesInView;
    for (UIGestureRecognizer* panner in _panners) {
        panner.cancelsTouchesInView = panningCancelsTouchesInView;
    }
}

- (void)setNavigationControllerBehavior:(IIViewDeckNavigationControllerBehavior)navigationControllerBehavior {
    if (!_viewFirstAppeared) {
        _navigationControllerBehavior = navigationControllerBehavior;
    }
    else {
        @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@"Cannot set navigationcontroller behavior when the view deck is already showing." userInfo:nil];
    }
}

- (void)setController:(UIViewController *)controller forSide:(IIViewDeckSide)side {
    UIViewController* prevController = _controllers[side];
    if (controller == prevController)
        return;

    __block IIViewDeckSide currentSide = IIViewDeckNoSide;
    [self doForControllers:^(UIViewController* sideController, IIViewDeckSide controllerSide) {
        if (controller == sideController)
            currentSide = controllerSide;
    }];
    void(^beforeBlock)() = ^{};
    void(^afterBlock)(UIViewController* controller) = ^(UIViewController* afterController){};
    
    __block CGRect newFrame = self.referenceBounds;
    if (_viewFirstAppeared) {
        beforeBlock = ^{
            [self notifyAppearanceForSide:side animated:NO from:2 to:1];
            [[self controllerForSide:side].view removeFromSuperview];
            [self notifyAppearanceForSide:side animated:NO from:1 to:0];
        };
        afterBlock = ^(UIViewController* afterController) {
            [self notifyAppearanceForSide:side animated:NO from:0 to:1];
//            [self hideAppropriateSideViews];
            afterController.view.frame = newFrame;
            afterController.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
            if (self.slidingController)
                [self.referenceView insertSubview:afterController.view belowSubview:self.slidingControllerView];
            else
                [self.referenceView addSubview:afterController.view];
            [self notifyAppearanceForSide:side animated:NO from:1 to:2];
        };
    }
    
    // start the transition
    if (prevController) {
        newFrame = prevController.view.frame;
        [prevController willMoveToParentViewController:nil];
        if (controller == self.centerController) self.centerController = nil;
        beforeBlock();
//        if (currentSide != IIViewDeckNoSide) _controllers[currentSide] = nil;
        [prevController setViewDeckController:nil];
        [prevController removeFromParentViewController];
        [prevController didMoveToParentViewController:nil];
    }
    
    // make the switch
    if (prevController != controller) {
//        _controllers[side] = controller;
    }
    
    if (controller) {
        // and finish the transition
        void(^finishTransition)(void) = ^{
            UIViewController* parentController = [[self parentViewController] parentViewController] ?: [self presentingViewController] ?: self;
            
            [parentController addChildViewController:controller];
            [controller setViewDeckController:self];
            afterBlock(controller);
            [controller didMoveToParentViewController:parentController];
            [self applyCenterViewOpacityIfNeeded];
        };
        
        [self enqueueFinishTransitionBlock:finishTransition forController:controller];
    }
}




- (void)setAutomaticallyUpdateTabBarItems:(BOOL)automaticallyUpdateTabBarItems {
    if (_automaticallyUpdateTabBarItems) {
        @try {
            [_centerController removeObserver:self forKeyPath:@"tabBarItem.title"];
            [_centerController removeObserver:self forKeyPath:@"tabBarItem.image"];
            [_centerController removeObserver:self forKeyPath:@"hidesBottomBarWhenPushed"];
        }
        @catch (NSException *exception) {}
    }
    
    _automaticallyUpdateTabBarItems = automaticallyUpdateTabBarItems;

    if (_automaticallyUpdateTabBarItems) {
        [_centerController addObserver:self forKeyPath:@"tabBarItem.title" options:0 context:nil];
        [_centerController addObserver:self forKeyPath:@"tabBarItem.image" options:0 context:nil];
        [_centerController addObserver:self forKeyPath:@"hidesBottomBarWhenPushed" options:0 context:nil];
        self.tabBarItem.title = _centerController.tabBarItem.title;
        self.tabBarItem.image = _centerController.tabBarItem.image;
    }
}


- (BOOL)setSlidingAndReferenceViews {
    if (self.navigationController && self.navigationControllerBehavior == IIViewDeckNavigationControllerIntegrated) {
        if ([self.navigationController.view superview]) {
            _slidingController = self.navigationController;
            self.referenceView = [self.navigationController.view superview];
            [self finishTransitionBlocks];
            return YES;
        }
    }
    else {
        _slidingController = self.centerController;
        self.referenceView = self.view;
        [self finishTransitionBlocks];
        return YES;
    }
    
    return NO;
}

- (UIView*)slidingControllerView {
    if (self.navigationController && self.navigationControllerBehavior == IIViewDeckNavigationControllerIntegrated) {
        return self.slidingController.view;
    }
    else {
        return self.centerView;
    }
}

#pragma mark - observation

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
    if (object == _centerController) {
        if ([@"tabBarItem.title" isEqualToString:keyPath]) {
            self.tabBarItem.title = _centerController.tabBarItem.title;
            return;
        }
        
        if ([@"tabBarItem.image" isEqualToString:keyPath]) {
            self.tabBarItem.image = _centerController.tabBarItem.image;
            return;
        }

        if ([@"hidesBottomBarWhenPushed" isEqualToString:keyPath]) {
            self.hidesBottomBarWhenPushed = _centerController.hidesBottomBarWhenPushed;
            self.tabBarController.hidesBottomBarWhenPushed = _centerController.hidesBottomBarWhenPushed;
            return;
        }
    }

    if ([@"title" isEqualToString:keyPath]) {
        if (!II_STRING_EQUAL([super title], self.centerController.title)) {
            self.title = self.centerController.title;
        }
        return;
    }
    
    if ([keyPath isEqualToString:@"bounds"]) {
//        [self setSlidingFrameForOffset:_offset forOrientation:_offsetOrientation animated:NO];
        self.slidingControllerView.layer.shadowPath = [UIBezierPath bezierPathWithRect:self.referenceBounds].CGPath;
        UINavigationController* navController = [self.centerController isKindOfClass:[UINavigationController class]] 
        ? (UINavigationController*)self.centerController 
        : nil;
        if (navController != nil && !navController.navigationBarHidden) {
            navController.navigationBarHidden = YES;
            navController.navigationBarHidden = NO;
        }
        return;
    }
    
    if ([keyPath isEqualToString:@"parentViewController"] || [keyPath isEqualToString:@"presentingViewController"]) {
        [self finishTransitionBlocks];
        
    }
}

#pragma mark - transition blocks

- (void)enqueueFinishTransitionBlock:(void(^)(void))finishTransition forController:(UIViewController*)controller {
    [controller willMoveToParentViewController:self];
    if (self.referenceView) {
        finishTransition();
    }
    else {
        [controller setViewDeckController:self]; // do this now since the transition block my run to late
        if (!_finishTransitionBlocks) {
            _finishTransitionBlocks = [NSMutableArray new];
            [self addObserver:self forKeyPath:@"parentViewController" options:0 context:nil];
            [self addObserver:self forKeyPath:@"presentingViewController" options:0 context:nil];
            self.isObservingSelf = YES;
        }
        [_finishTransitionBlocks addObject:finishTransition];
    }
}

- (void)finishTransitionBlocks {
    if (!self.referenceView) return;
    
    if (_finishTransitionBlocks) {
        if (self.isObservingSelf) {
            @try {
                [self removeObserver:self forKeyPath:@"parentViewController" context:nil];
                [self removeObserver:self forKeyPath:@"presentingViewController" context:nil];
                self.isObservingSelf = NO;
            } @catch (id anException) {
                
            }
        }
        
        for (void(^finishTransition)(void) in _finishTransitionBlocks) {
            finishTransition();
        }
        _finishTransitionBlocks = nil;
    }
}

#pragma mark - Center Opacity

- (void)setCenterViewOpacity:(CGFloat)centerViewOpacity {
    _centerViewOpacity = centerViewOpacity;
    
//    if (centerViewOpacity < 1 && [self sideControllerCount] > 1) {
//        NSLog(@"IIViewDeckController: warning: setting centerViewOpacity to value different than 1 with more than one side controller. Value will be ignored.");
//        return;
//    }
    
    [self applyCenterViewOpacityIfNeeded];
}

- (void)applyCenterViewOpacityIfNeeded {
    if (!self.centerController.view)
        return;
    
//    if ([self sideControllerCount] > 1) {
//        // more than once controller => not opaque
//        if (self.centerController.view.alpha < 1) {
//            self.centerController.view.alpha = 1;
//            self.centerController.view.opaque = YES;
//        }
//        return;
//    }
    
    self.centerController.view.alpha = _centerViewOpacity;
    self.centerController.view.opaque = NO;
}

#pragma mark - Center corner radius

- (void)setCenterViewCornerRadius:(CGFloat)centerViewCornerRadius {
    _centerViewCornerRadius = centerViewCornerRadius;
    [self applyCenterViewCornerRadiusAnimated:NO];
}

- (UIBezierPath*)generateCenterViewCornerRadiusPath {
    CGRect rect = self.slidingControllerView.layer.bounds;
    if (_centerViewCornerRadius == 0)
        return [UIBezierPath bezierPathWithRect:rect];
    
    // create mask path
    CGSize radius = (CGSize) { _centerViewCornerRadius, _centerViewCornerRadius };
    UIRectCorner corners = 0;
    if (self.leftController)
        corners |= UIRectCornerTopLeft | UIRectCornerBottomLeft;
    if (self.rightController)
        corners |= UIRectCornerTopRight | UIRectCornerBottomRight;
    UIBezierPath* path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radius];
    
    return path;
}

- (void)applyCenterViewCornerRadiusAnimated:(BOOL)animated {
    UIBezierPath* path = [self generateCenterViewCornerRadiusPath];
    CALayer *shadowLayer = self.slidingControllerView.layer;
    
    if (animated) {
        CGFloat duration = 0.3;
        CAMediaTimingFunction* timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
        [self currentAnimationDuration:&duration timingFunction:&timingFunction];

        CABasicAnimation* anim;
        anim = [CABasicAnimation animationWithKeyPath:@"shadowPath"];
        anim.duration = duration;
        anim.timingFunction = timingFunction;
        anim.fromValue = (id)shadowLayer.shadowPath;
        anim.toValue = (id)[path CGPath];
        anim.fillMode = kCAFillModeForwards;
        [shadowLayer addAnimation:anim forKey:@"animateShadowPath"];
    }

    shadowLayer.shadowPath = [path CGPath];
}



#pragma mark - Shadow

- (void)setShadowEnabled:(BOOL)shadowEnabled animated:(BOOL)animated {
    _shadowEnabled = shadowEnabled;
    
    if (shadowEnabled)
        [self applyShadowToSlidingViewAnimated:animated];
    else
        [self restoreShadowToSlidingView];
}

- (void)setShadowEnabled:(BOOL)shadowEnabled {
    [self setShadowEnabled:shadowEnabled animated:NO];
}

- (void)restoreShadowToSlidingView {
    UIView* shadowedView = self.slidingControllerView;
    if (!shadowedView) return;
    
    CALayer *shadowLayer = shadowedView.layer;
    shadowLayer.shadowOpacity = 0.0;
    shadowLayer.shadowPath = nil;
}

- (void)applyShadowToSlidingViewAnimated:(BOOL)animated {
    if (!self.shadowEnabled) return;

    UIView* shadowedView = self.slidingControllerView;
    if (!shadowedView) return;
    
    CALayer *shadowLayer = shadowedView.layer;
    
    if ([self.delegate respondsToSelector:@selector(viewDeckController:applyShadow:withBounds:)]) {
        [self.delegate viewDeckController:self applyShadow:shadowLayer withBounds:self.referenceBounds];
    }
    else {
        shadowLayer.masksToBounds = NO;
        shadowLayer.shadowRadius = 10;
        shadowLayer.shadowOpacity = 0.5;
        shadowLayer.shadowColor = [[UIColor blackColor] CGColor];
        shadowLayer.shadowOffset = CGSizeZero;
        shadowLayer.shadowPath = [[UIBezierPath bezierPathWithRect:shadowLayer.bounds] CGPath];
        if (animated) {
            CABasicAnimation* anim = [CABasicAnimation animationWithKeyPath:@"shadowOpacity"];
            anim.fromValue = @(0.0);
            anim.duration = 1.0;
            anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
            anim.fillMode = kCAFillModeForwards;
            [shadowLayer addAnimation:anim forKey:@"animateShadowOpacity"];
        }
    }
}

- (BOOL)currentAnimationDuration:(CGFloat*)duration timingFunction:(CAMediaTimingFunction**)timingFunction {
    for (NSString* key in self.slidingControllerView.layer.animationKeys) {
        if ([key isEqualToString:@"position"]) {
            CABasicAnimation* other = (CABasicAnimation*)[self.slidingControllerView.layer animationForKey:key];
            
            if ([other isKindOfClass:[CABasicAnimation class]]) {
                *duration = other.duration;
                *timingFunction = other.timingFunction;
                return YES;
            }
        }
    }
    
    return NO;
}
@end

#pragma mark -

@implementation IIViewDeckView

@synthesize allowUserInteractionEnabled = _allowUserInteractionEnabled;

- (id)init {
    if ((self = [super init])) {
        _allowUserInteractionEnabled = YES;
        _userInteractionEnabled = [self isUserInteractionEnabled];
    }
    return self;
}

- (id)initWithCoder:(NSCoder *)aDecoder {
    if ((self = [super initWithCoder:aDecoder])) {
        _allowUserInteractionEnabled = YES;
        _userInteractionEnabled = [self isUserInteractionEnabled];
    }
    return self;
}

- (id)initWithFrame:(CGRect)frame {
    if ((self = [super initWithFrame:frame])) {
        _allowUserInteractionEnabled = YES;
        _userInteractionEnabled = [self isUserInteractionEnabled];
    }
    return self;
}

- (void)setAllowUserInteractionEnabled:(BOOL)allowUserInteractionEnabled {
    _allowUserInteractionEnabled = allowUserInteractionEnabled;
    [super setUserInteractionEnabled:_allowUserInteractionEnabled && _userInteractionEnabled];
}

- (void)setUserInteractionEnabled:(BOOL)userInteractionEnabled {
    _userInteractionEnabled = userInteractionEnabled;
    [super setUserInteractionEnabled:_allowUserInteractionEnabled && _userInteractionEnabled];
}

- (void)setNeedsOffsetAdjustment {
    _needsOffsetAdjustment = YES;
}

- (BOOL)needsOffsetAdjustment {
    return _needsOffsetAdjustment;
}

@end

@implementation UIViewController (UIViewDeckItem)

@dynamic viewDeckController;

static const char* viewDeckControllerKey = "ViewDeckController";

- (IIViewDeckController*)viewDeckController_core {
    return objc_getAssociatedObject(self, viewDeckControllerKey);
}

- (IIViewDeckController*)viewDeckController {
    IIViewDeckController* result = [self viewDeckController_core];
    if (!result && self.navigationController) {
        result = [self.navigationController viewDeckController_core];
        if (!result) {
            for (UIViewController* controller in [self.navigationController.viewControllers reverseObjectEnumerator]) {
                if ([controller isKindOfClass:[IIViewDeckController class]])
                    result = (IIViewDeckController*)controller;
                else
                    result = [controller viewDeckController_core];
                if (result) {
                    if (result.navigationControllerBehavior == IIViewDeckNavigationControllerIntegrated)
                        break;
                    result = nil;
                }
            }
        }
    }
    if (!result && [self respondsToSelector:@selector(wrapController)] && self.wrapController)
        result = [self.wrapController viewDeckController];
    
    return result;
}

- (void)setViewDeckController:(IIViewDeckController*)viewDeckController {
    objc_setAssociatedObject(self, viewDeckControllerKey, viewDeckController, OBJC_ASSOCIATION_ASSIGN);
}

- (UINavigationController*)vdc_navigationController {
    UIViewController* controller = self.viewDeckController_core ? self.viewDeckController_core : self;
    return [controller vdc_navigationController]; // when we get here, the vdc_ method is actually the old, real method
}

- (UINavigationItem*)vdc_navigationItem {
    UIViewController* controller = self.viewDeckController_core ? self.viewDeckController_core : self;
    return [controller vdc_navigationItem]; // when we get here, the vdc_ method is actually the old, real method
}

+ (void)vdc_swizzle {
    SEL nc = @selector(navigationController);
    SEL vdcnc = @selector(vdc_navigationController);
    method_exchangeImplementations(class_getInstanceMethod(self, nc), class_getInstanceMethod(self, vdcnc));
    
    SEL ni = @selector(navigationItem);
    SEL vdcni = @selector(vdc_navigationItem);
    method_exchangeImplementations(class_getInstanceMethod(self, ni), class_getInstanceMethod(self, vdcni));
    
    // view containment drop ins for <ios5
    SEL willMoveToPVC = @selector(willMoveToParentViewController:);
    SEL vdcWillMoveToPVC = @selector(vdc_willMoveToParentViewController:);
    if (!class_getInstanceMethod(self, willMoveToPVC)) {
        Method implementation = class_getInstanceMethod(self, vdcWillMoveToPVC);
        class_addMethod([UIViewController class], willMoveToPVC, method_getImplementation(implementation), "v@:@"); 
    }
    
    SEL didMoveToPVC = @selector(didMoveToParentViewController:);
    SEL vdcDidMoveToPVC = @selector(vdc_didMoveToParentViewController:);
    if (!class_getInstanceMethod(self, didMoveToPVC)) {
        Method implementation = class_getInstanceMethod(self, vdcDidMoveToPVC);
        class_addMethod([UIViewController class], didMoveToPVC, method_getImplementation(implementation), "v@:"); 
    }
    
    SEL removeFromPVC = @selector(removeFromParentViewController);
    SEL vdcRemoveFromPVC = @selector(vdc_removeFromParentViewController);
    if (!class_getInstanceMethod(self, removeFromPVC)) {
        Method implementation = class_getInstanceMethod(self, vdcRemoveFromPVC);
        class_addMethod([UIViewController class], removeFromPVC, method_getImplementation(implementation), "v@:"); 
    }
    
    SEL addCVC = @selector(addChildViewController:);
    SEL vdcAddCVC = @selector(vdc_addChildViewController:);
    if (!class_getInstanceMethod(self, addCVC)) {
        Method implementation = class_getInstanceMethod(self, vdcAddCVC);
        class_addMethod([UIViewController class], addCVC, method_getImplementation(implementation), "v@:@"); 
    }
}

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        @autoreleasepool {
            [self vdc_swizzle];
        }
    });
}


@end

#ifndef EXTRA_APPSTORE_SAFETY

@implementation UIView (UIViewDeckView_HandleOffsetAdjustment)

+ (void)vdc_swizzle {
    SEL asv = @selector(addSubview:);
    SEL vdcasv = @selector(vdc_addSubview:);
    method_exchangeImplementations(class_getInstanceMethod(self, asv), class_getInstanceMethod(self, vdcasv));
}

- (void)vdc_addSubview:(UIView *)view {
    if ([view isKindOfClass:[IIViewDeckView class]]) {
        if ([self isKindOfClass:NSClassFromString(@"UITransitionView")]) {
            // if the view needs offset adjustment (in case of a navigation controller), do it
            if ([(IIViewDeckView*)view needsOffsetAdjustment]) {
                CGRect fondlyRememberedFrame = view.frame; // remember the frame since it's actually correct
                
                // offset it
                view.frame = (CGRect) { view.frame.origin.x, 0, view.frame.size.width, view.frame.size.height + view.frame.origin.y };
                // remember the duration of the generated animation (since were in a transition view) to be able to
                // dispatch_after so we can correct this back at the correct time
                CGFloat duration = [view.layer animationForKey:@"position"].duration;
                
                dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));
                dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
                    // restore the correct frame
                    view.frame = fondlyRememberedFrame;
                });
                
                // recursively remove all animations (those are just position and bounds animations on all subviews)
                [self vdc_removeAllAnimationsRecursive:view];
                
            }
        }
    }
    
    // do your stuff, UIView
    [self vdc_addSubview:view];
}

- (void)vdc_removeAllAnimationsRecursive:(UIView*)view {
    [view.layer removeAllAnimations];
    for (UIView* subview in view.subviews) {
        [self vdc_removeAllAnimationsRecursive:subview];
    }
}

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        @autoreleasepool {
            [self vdc_swizzle];
        }
    });
}

@end

#endif


@implementation UIViewController (UIViewDeckController_ViewContainmentEmulation_Fakes)

- (void)vdc_addChildViewController:(UIViewController *)childController {
    // intentionally empty
}

- (void)vdc_removeFromParentViewController {
    // intentionally empty
}

- (void)vdc_willMoveToParentViewController:(UIViewController *)parent {
    // intentionally empty
}

- (void)vdc_didMoveToParentViewController:(UIViewController *)parent {
    // intentionally empty
}

@end
